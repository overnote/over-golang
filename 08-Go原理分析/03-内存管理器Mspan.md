## 内存管理器Mspan
#### 1.1 简介
Go语言内存管理器是基于TCMalloc实现的，底层直接调用mmap函数，并使用bestfit进行动态分配。不过Go也做了一些优化，Go的内存分为两部分：
```
堆：提供内存分配
bitmap：管理堆
```
这两部分内存都是从同一个地址开始申请的，向高地址的方向增长的就是内存池，向低地址增长的是bitmap。
Go为每个系统线程分配了一个本地MCache，少量的地址分配是从MCache开始的，并且定期进行垃圾回收，所以Go的分配器包含了显式和隐式调用。
Go内存分配的主要组件：
- Mcache: 每个尺寸的class都有一个空闲链表，每个线程都有自己局部Mcache（小对象从这里取，无锁，无竞争，十分高效）
- MCentral：Mcache可以在这里获取更多内存，当自身无空闲内存时，可以向MHeap申请一个span（只能一个），申请的span包含多少个page由cebtral的sizeclass决定
- MHeap：负责将MSpan组织管理起来。从free数组中分配，如果发生切割则将生于的部分放回free数组中。回收过程也类似，回收一个Mspan时，先查它的相邻地址，再通过map映射得到对应的Mspan，如果Mspan状态未使用，则两者合并，最后将这个page或者合并后的page归还到free数组分配池或large中。
![](../images/Golang/内存-04.png)
如图所示不一样的地方：用户进程newobject式从arena区域分配的，而runtime层自身管理结构式专门设计了fixAlloc分配的，和TCMalloc很不一样。
在Go中，内存分配有三个概念：
```
G:Goroutine上下文环境
M：操作系统线程
P：Processer进程调度器，近于CPU
```
通常情况下，分配内存都是通过new，malloc等API申请的，由于所申请的内存块的大小不定，当频繁使用时会造成大量的内存碎片导致降低性能。
于是有了内存池，在真正使用内存前，先申请一块大内存，如1MB，并把分配到的内存划分位一定数量的，大小相等（一般而言）的小内存块构成链表，留作备用。当有新内存需求时，就从内存池中分出一小部分内存块即可。若内存块不够再继续申请新的内存，如果内存闲置过多则将部分内存归还给操作系统。
但是在Go中，内存分配器只管理内存块，不关心对象的状态，不会主动回收内存，需要垃圾回收器完成清理操作，再出发内存管理器回收内存。